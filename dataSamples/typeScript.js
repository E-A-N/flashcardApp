globalRoutines.typeScript = () => {
    let questionData = [
        {question: "What are the key differences between TypeScript and JavaScript?", answer: "TypeScript is a superset of JavaScript that adds static typing, interfaces, and advanced features such as generics and enums. It provides compile-time type checking, which helps catch errors early and improves code quality and maintainability. JavaScript, on the other hand, is a dynamically typed language without these features."},

        {question: "How do you define and use generics in TypeScript?", answer: "Generics allow you to create reusable and flexible components that can work with a variety of types while maintaining type safety. You define a generic type by using angle brackets (`<T>`) in your function, class, or interface. For example, `function identity<T>(arg: T): T { return arg; }` defines a generic function that works with any type."},

        {question: "What is the difference between `interface` and `type` in TypeScript?", answer: "Both `interface` and `type` can be used to define types in TypeScript, but they have some differences. `interface` is typically used for defining object shapes and can be extended or merged using the `extends` keyword. `type` is more versatile and can define union types, intersection types, and more. Interfaces are usually preferred for object-oriented designs, while types offer more flexibility for complex type operations."},

        {question: "Explain the concept of 'type inference' in TypeScript.", answer: "Type inference in TypeScript is the ability of the compiler to automatically deduce the type of a variable or expression based on its value or context without explicit type annotations. For example, `let num = 42;` infers `num` to be of type `number`. This reduces the need for redundant type annotations and improves code readability."},

        {question: "What are 'decorators' in TypeScript and how are they used?", answer: "Decorators are special functions that can be applied to classes, methods, properties, or parameters to add metadata or modify their behavior. They are defined using the `@decoratorName` syntax and are often used for scenarios like dependency injection, logging, or validation. Decorators require enabling the `experimentalDecorators` option in the TypeScript configuration."},

        {question: "How does TypeScript handle module resolution and what are some common strategies for configuring it?", answer: "TypeScript handles module resolution by following a set of rules to locate and load modules based on their import paths. Configuration options like `baseUrl`, `paths`, and `rootDirs` in `tsconfig.json` help customize module resolution. Common strategies include setting up absolute imports using `baseUrl`, creating path aliases with `paths`, and ensuring consistent module resolution across different environments."},

        {question: "What are 'mapped types' and how are they used in TypeScript?", answer: "Mapped types allow you to create new types by transforming the properties of an existing type. They use the `keyof` operator and the `in` keyword to iterate over the properties of a type. For example, `type Readonly<T> = { readonly [K in keyof T]: T[K] };` creates a type with all properties of `T` set to `readonly`."},

        {question: "Explain how TypeScript’s type guards work and provide examples.", answer: "Type guards are functions or expressions that narrow down the type of a variable within a specific scope. They are used to ensure type safety when dealing with union types or different types in conditional statements. Examples include using the `typeof` operator, `instanceof` operator, or custom type guard functions like `function isString(value: any): value is string { return typeof value === 'string'; }`."},

        {question: "What is the purpose of 'utility types' in TypeScript, and can you name a few?", answer: "Utility types are predefined types provided by TypeScript to assist with common type transformations and manipulations. Examples include `Partial<T>`, which makes all properties of `T` optional; `Required<T>`, which makes all properties of `T` required; `Pick<T, K>`, which selects specific properties from `T`; and `Omit<T, K>`, which excludes specific properties from `T`."},

        {question: "How can you use TypeScript with existing JavaScript libraries and what are the best practices?", answer: "You can use TypeScript with JavaScript libraries by installing type definitions from DefinitelyTyped (`@types` packages) or by writing your own type declarations. Best practices include ensuring that type definitions are up-to-date, using `any` type cautiously, and leveraging TypeScript’s `allowJs` option to gradually migrate JavaScript codebases to TypeScript."},

        {question: "What are 'conditional types' and how do they work in TypeScript?", answer: "Conditional types allow you to define a type based on a condition. They use the `T extends U ? X : Y` syntax to evaluate a type `T` against another type `U` and choose between two types `X` or `Y` based on whether `T` extends `U`. For example, `type IsString<T> = T extends string ? 'Yes' : 'No';` results in `'Yes'` if `T` is `string` and `'No'` otherwise."},

        {question: "Describe how TypeScript’s 'index types' work and provide an example.", answer: "Index types allow you to use dynamic property names to access or define properties of an object type. They use the syntax `[key: string]: Type` to define properties with dynamic keys. For example, `interface Dictionary { [key: string]: number; }` allows any string key with a `number` value."},

        {question: "How do you implement custom type assertions in TypeScript?", answer: "Custom type assertions are used to assert a specific type for a value. They are implemented using the `as` keyword or the angle bracket syntax (`<type>`). For example, `let someValue: any = 'hello'; let strLength: number = (someValue as string).length;` asserts `someValue` as `string` and accesses its `length` property."},

        {question: "What are 'type aliases' and how do they differ from interfaces?", answer: "Type aliases are used to create a new name for a type and can represent primitive types, union types, intersection types, and more. They are defined using the `type` keyword, e.g., `type Point = { x: number; y: number; }`. Interfaces, on the other hand, are specifically designed for defining object shapes and can be extended or merged. Type aliases offer more flexibility in defining complex types."},

        {question: "How does TypeScript’s 'type narrowing' work with control flow analysis?", answer: "Type narrowing refers to the process of refining a variable’s type based on control flow analysis within conditional statements. TypeScript uses control flow analysis to narrow down the type of a variable as the code executes. For example, within an `if` statement checking `typeof x === 'string'`, TypeScript knows `x` is a string inside the block, allowing for string-specific operations."},

        {question: "Explain how 'declaration merging' works in TypeScript.", answer: "Declaration merging allows you to combine multiple declarations of the same name into a single definition. It is commonly used with interfaces, where multiple interface declarations with the same name are automatically merged. For example, `interface A { x: number; }` and `interface A { y: string; }` will be merged into `interface A { x: number; y: string; }`."},

        {question: "What are 'tuple types' in TypeScript, and how are they used?", answer: "Tuple types represent an array with a fixed number of elements where each element can have a different type. They are defined using square brackets with types for each element, e.g., `let tuple: [number, string] = [1, 'hello'];`. Tuples are useful for representing structured data with a known length and type for each position."},

        {question: "How do you handle type compatibility in TypeScript with respect to structural typing?", answer: "TypeScript uses structural typing, meaning that types are compatible based on their members rather than their names. For example, if a type has the same shape as another type (i.e., it has the same properties with compatible types), it is considered compatible. This allows for flexible and modular code but requires careful management of type structures."},

        {question: "What is the purpose of the `never` type in TypeScript?", answer: "`never` represents values that never occur. It is used to indicate that a function will not complete normally, such as a function that always throws an error or enters an infinite loop. For example, `function throwError(message: string): never { throw new Error(message); }` indicates that `throwError` will never return a value."},

        {question: "Describe how TypeScript’s 'namespace' feature works and its use cases.", answer: "Namespaces are a way to group related code in TypeScript. They provide a way to organize code into logical units and avoid naming conflicts. Namespaces are declared using the `namespace` keyword and are often used in conjunction with internal modules. They help structure code in large projects but are less commonly used in modern codebases compared to ES modules."},

        {question: "How can you leverage TypeScript’s `type guards` for type-safe programming?", answer: "Type guards are functions or constructs that allow you to narrow down the type of a variable in a specific context. For example, using `typeof` checks, `instanceof` checks, or custom type guard functions helps ensure that operations on variables are type-safe. This leads to more reliable and maintainable code by preventing type errors."},

        {question: "What are 'type predicates' and how do they enhance type safety in TypeScript?", answer: "Type predicates are functions that return a boolean value and provide a type guard that refines the type of a variable within a conditional block. They use the syntax `value is Type` to assert that the value is of the specified type. For example, `function isString(value: any): value is string { return typeof value === 'string'; }` ensures that `value` is a string within the block where this function returns true."},

        {question: "Explain how TypeScript’s 'ambient declarations' work and when to use them.", answer: "Ambient declarations allow you to define types or values that exist outside the TypeScript project, such as in external libraries or global variables. They are declared using the `declare` keyword, e.g., `declare const MY_GLOBAL: string;`. They are useful for integrating with existing JavaScript code or libraries that do not have TypeScript definitions."}
    ];
    localStorage.setItem("flash-cards", JSON.stringify(questionData));
    if (typeof startTest === "function"){
        startTest();
    }
}